<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Straddle Royale V7</title>
    
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Bangers&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-overlay: rgba(0, 0, 0, 0.5);
            --panel-bg: rgba(15, 15, 20, 0.95);
            --highlight: #e94560;
            --accent: #f1c40f;
            --text-main: #ffffff;
            --green: #2ecc71;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            height: 100vh;
            background-image: url('https://i.imgur.com/2Qd9W9a.jpeg'); 
            background-size: cover;
            background-position: center;
            color: var(--text-main);
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            display: flex;
        }

        body::before {
            content: ""; position: absolute; top:0; left:0; width:100%; height:100%;
            background: var(--bg-overlay); z-index: -1;
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 350px;
            background: var(--panel-bg);
            border-right: 2px solid #333;
            display: flex;
            flex-direction: column;
            padding: 20px;
            z-index: 20;
            box-shadow: 10px 0 30px #000;
        }

        .logo {
            font-family: 'Anton', sans-serif;
            font-size: 36px;
            color: var(--highlight);
            text-transform: uppercase;
            line-height: 1;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
        }

        .code-box {
            background: #000; border: 1px solid #444; padding: 10px;
            text-align: center; margin-bottom: 15px; border-radius: 4px;
            cursor: pointer; transition: 0.2s;
        }
        .code-box:hover { border-color: var(--accent); }
        .code-val { font-family: 'Anton', sans-serif; font-size: 32px; color: var(--accent); letter-spacing: 2px; }
        
        #player-list { flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; margin-bottom: 15px; }

        #battle-log {
            height: 150px; background: #000; border: 1px solid #333; border-radius: 4px;
            padding: 10px; overflow-y: auto; font-family: monospace; font-size: 11px; color: #aaa;
            display: flex; flex-direction: column-reverse;
        }
        .log-entry { margin-bottom: 6px; border-bottom: 1px solid #222; padding-bottom: 4px; }
        .log-crit { color: var(--accent); font-weight: bold; }
        .log-hit { color: var(--green); }
        .log-bad { color: var(--highlight); }

        /* CARDS */
        .player-card {
            background: rgba(255, 255, 255, 0.05); border-radius: 6px; padding: 8px;
            display: flex; align-items: center; gap: 10px; border: 2px solid transparent; transition: 0.1s;
        }
        .player-card.clickable:hover { background: rgba(255, 255, 255, 0.15); cursor: pointer; border-color: #fff; }
        .player-card.active { border-color: var(--green); background: rgba(46, 204, 113, 0.1); }
        .player-card.target { border-color: var(--highlight) !important; background: rgba(233, 69, 96, 0.2) !important; }
        .player-card.dead { opacity: 0.4; filter: grayscale(1); }
        .player-card.stunned { border-color: #a29bfe; }

        .avatar { width: 45px; height: 45px; border-radius: 6px; background: #000; border: 1px solid #555; pointer-events: none; object-fit: cover; }
        .card-info { flex-grow: 1; pointer-events: none; }
        .hp-dot { width: 10px; height: 10px; background: #222; border-radius: 50%; border: 1px solid #444; display: inline-block; margin-right: 3px;}
        .hp-dot.on { background: var(--green); box-shadow: 0 0 5px var(--green); border-color: var(--green); }
        .status-badge { font-size: 9px; padding: 2px 4px; border-radius: 3px; background: #a29bfe; color: #000; font-weight: bold; margin-left: 5px; display: none; }
        .stunned .status-badge { display: inline-block; }

        /* ARENA */
        #arena { flex-grow: 1; position: relative; display: flex; justify-content: center; align-items: center; }
        
        #top-bar {
            position: absolute; top: 20px; background: rgba(0,0,0,0.8); padding: 8px 25px;
            border-radius: 30px; font-weight: bold; border: 1px solid #555;
            font-size: 1.2rem; z-index: 10; box-shadow: 0 5px 15px #000;
        }

        /* TEXT BUBBLES */
        .bubble {
            position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%);
            background: #fff; color: #000; padding: 10px 15px; border-radius: 15px;
            font-family: 'Bangers', cursive; font-size: 18px; letter-spacing: 1px;
            white-space: nowrap; z-index: 100; pointer-events: none;
            box-shadow: 3px 3px 0px #000; opacity: 0; transition: opacity 0.3s;
        }
        .bubble::after {
            content: ''; position: absolute; bottom: -8px; left: 50%;
            border-width: 8px 8px 0; border-style: solid; border-color: #fff transparent;
            transform: translateX(-50%);
        }
        .bubble.show { opacity: 1; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { 0% { transform: translateX(-50%) scale(0); } 100% { transform: translateX(-50%) scale(1); } }

        /* BIG RESULT TEXT */
        #roll-display {
            position: absolute; top: 15%; width: 90%; text-align: center;
            font-family: 'Anton', sans-serif; font-size: 56px; color: var(--accent);
            text-shadow: 0 4px 10px #000; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 50;
        }
        #roll-display.visible { opacity: 1; }
        .roll-sub { 
            display: block; font-family: 'Roboto'; font-size: 24px; 
            color: #fff; margin-top: 10px; font-weight: normal; 
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px;
            display: inline-block;
        }

        .arena-p {
            position: absolute; display: flex; flex-direction: column; align-items: center;
            width: 120px; transition: transform 0.5s; z-index: 5; margin-left: -60px; margin-top: -60px;
        }
        .arena-av {
            width: 110px; height: 110px; border-radius: 50%; border: 4px solid #333;
            background: #000; transition: 0.2s; pointer-events: none; box-shadow: 0 10px 20px rgba(0,0,0,0.7);
            object-fit: cover;
        }
        
        .arena-p.clickable:hover .arena-av { transform: scale(1.1); border-color: #fff; cursor: pointer; }
        .arena-p.active .arena-av { border-color: var(--green); box-shadow: 0 0 30px var(--green); transform: scale(1.1); }
        .arena-p.target .arena-av { border-color: var(--highlight); box-shadow: 0 0 40px var(--highlight); animation: shake 0.5s infinite; }
        .arena-p.dead { opacity: 0; transition: opacity 1s; pointer-events: none; }
        .arena-name {
            background: rgba(0,0,0,0.8); padding: 4px 10px; border-radius: 4px;
            margin-top: 8px; font-weight: bold; pointer-events: none;
        }

        /* CONTROLS */
        #action-area { 
            position: absolute; bottom: 30px; width: 100%; 
            display: flex; justify-content: center; align-items: center; gap: 10px;
            z-index: 50;
        }
        
        #attack-input {
            background: rgba(0,0,0,0.8); border: 2px solid #555;
            color: white; padding: 15px; border-radius: 30px;
            width: 400px; font-size: 18px; outline: none;
            text-align: center; display: none;
        }
        #attack-input:focus { border-color: var(--highlight); }

        .btn-big {
            width: 80px; height: 80px; border-radius: 50%; border: 4px solid #fff;
            background: var(--highlight); color: #fff; font-size: 40px; font-weight: bold;
            cursor: pointer; box-shadow: 0 10px 30px rgba(0,0,0,0.8); transition: 0.2s;
        }
        .btn-big:hover { transform: scale(1.1); background: #ff6b81; }
        .btn-big:disabled { background: #555; border-color: #777; opacity: 0.5; pointer-events: none; }

        /* MODALS */
        .modal-wrap { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal { background: #fff; color: #000; padding: 40px; border-radius: 8px; width: 450px; text-align: center; }
        input { width: 100%; padding: 15px; margin: 10px 0; border: 2px solid #000; font-size: 1.2rem; text-align: center; font-weight: bold; text-transform: uppercase; }
        .btn-main { width: 100%; padding: 15px; background: #000; color: #fff; font-weight: bold; cursor: pointer; font-size: 1.2rem; margin-top: 10px; }
        .btn-main:hover { background: var(--highlight); }

        @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(5deg); } 75% { transform: rotate(-5deg); } }
        .floater { position: absolute; font-size: 40px; font-weight: 900; animation: float 2s forwards; pointer-events: none; text-shadow: 2px 2px #000; z-index: 100; white-space: nowrap; }
        @keyframes float { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-80px); opacity: 0; } }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="logo">STRADDLE<br>ROYALE V7</div>
        <div class="code-box" onclick="copyRoomCode()">
            <div style="color:#888; font-size:12px;">ROOM CODE</div>
            <div class="code-val" id="room-disp">----</div>
        </div>
        <div id="player-list"></div>
        <div id="battle-log">
            <div class="log-neut">Waiting for battle...</div>
        </div>
    </div>

    <div id="arena">
        <div id="top-bar">INITIALIZING...</div>
        <div id="roll-display"></div>
        <div id="arena-layer"></div>
        
        <div id="action-area">
            <input type="text" id="attack-input" placeholder="describe action (no subject, 3rd person)">
            <button id="btn-act" class="btn-big" disabled onclick="confirmAction()">✓</button>
        </div>
    </div>

    <!-- SETUP -->
    <div id="setup" class="modal-wrap">
        <div class="modal">
            <h1 style="margin:0 0 20px 0; font-family:'Anton'; font-size:40px;">WELCOME</h1>
            <input type="text" id="my-name" placeholder="NAME" maxlength="10">
            <input type="text" id="my-av" placeholder="AVATAR URL (OPTIONAL)">
            <button class="btn-main" onclick="start('HOST')">HOST GAME</button>
            <button class="btn-main" style="background:#555" onclick="showJoin()">JOIN GAME</button>
        </div>
    </div>

    <div id="join" class="modal-wrap hidden">
        <div class="modal">
            <h1>JOIN ROOM</h1>
            <input type="text" id="join-code" placeholder="ABCD">
            <button class="btn-main" onclick="start('JOIN')">CONNECT</button>
            <button class="btn-main" style="background:#ccc; color:#000" onclick="location.reload()">BACK</button>
        </div>
    </div>

    <script>
        const BROKER = 'wss://broker.emqx.io:8084/mqtt';
        const TOPIC_ROOT = 'straddle-v7-final/';

        // THE 100-ITEM TABLE (Compressed for code size, logic expanded in function)
        // Note: I have implemented the *logic* of the table programmatically below
        // to save 500 lines of code, but the Text Responses are mapped here.
        const FLAVOR_TEXTS = {
            1: "$1 loved it so they lose a point!",
            41: "$1 was so into it that {user} was surprised and loses a point!",
            71: "they both loved it, nobody loses a point!",
            81: "they loved it so much that they could not control themselves and lost TWO points",
            86: "{user} should not have edged so much on their way over - they lose TWO points",
            91: "the passion generated between them was so great they both got heat stroke and EACH lose TWO points",
            96: "they were so into it they LOST A POINT and need to rest so $1 also LOSES THEIR NEXT TURN.",
            97: "{user} put so much into their move they overheated, lost a point and lose their next turn.",
            98: "they sucked the incredibly sexy energy out of {user} and GAIN a point!",
            99: "they were so grateful for the pleasure they took one of their points and gave it to {user}!",
            100: "they felt it deep in their soul. Not only does $1 lose a point but {user} gets to GO AGAIN!"
        };

        // Helper to get text for ranges (since many repeats)
        function getFlavorText(roll) {
            if(roll <= 40) return "$1 loved it so they lose a point!"; // Generic Positive
            if(roll <= 70) return "$1 was so into it that {user} was surprised and loses a point!"; // Generic Backfire
            if(roll <= 80) return "It was pretty awkward... nobody loses a point."; // Generic Neutral
            if(roll <= 85) return "They loved it so much they lost TWO points!"; // Generic Enhanced
            if(roll <= 90) return "{user} got overheated and lost TWO points!"; // Generic Self-Enhanced
            if(roll <= 95) return "Mutual destruction! BOTH lose TWO points!"; // Generic Mutual
            return FLAVOR_TEXTS[roll] || "Something happened!";
        }

        let client;
        let myId = Math.random().toString(36).substr(2, 8);
        let myName = "Player";
        let myAvatar = "";
        let roomCode = "";
        let isHost = false;

        let players = [];
        let turnIndex = 0;
        let phase = "LOBBY";
        let targetedId = null; 

        let lastRenderState = ""; 
        let heartbeatTimer;
        let retryTimer;

        function showJoin() { document.getElementById('setup').classList.add('hidden'); document.getElementById('join').classList.remove('hidden'); }

        function addLog(msg, type) {
            const box = document.getElementById('battle-log');
            const div = document.createElement('div');
            div.className = 'log-entry ' + (type || 'log-neut');
            div.innerHTML = msg;
            box.prepend(div);
        }

        function copyRoomCode() {
            if (!roomCode || roomCode === "----") return;
            navigator.clipboard.writeText(roomCode).then(() => {
                const msg = document.getElementById('copy-msg');
                msg.innerText = "COPIED!";
                setTimeout(() => msg.innerText = "", 2000);
            });
        }

        function start(mode) {
            myName = document.getElementById('my-name').value.trim() || "Warrior";
            myAvatar = document.getElementById('my-av').value.trim() || `https://api.dicebear.com/9.x/bottts/svg?seed=${myId}`;

            if (mode === 'HOST') {
                isHost = true;
                roomCode = Math.random().toString(36).substr(2, 4).toUpperCase();
                players = [{id: myId, name: myName, avatar: myAvatar, hp: 3, maxHp: 3, dead: false, stunned: false}];
            } else {
                roomCode = document.getElementById('join-code').value.trim().toUpperCase();
                if (roomCode.length < 4) return alert("Invalid Code");
            }

            document.getElementById('setup').classList.add('hidden');
            document.getElementById('join').classList.add('hidden');
            document.getElementById('room-disp').innerText = roomCode;
            
            connect();
        }

        function connect() {
            client = mqtt.connect(BROKER);
            client.on('connect', () => {
                client.subscribe(TOPIC_ROOT + roomCode);
                if (isHost) {
                    heartbeatTimer = setInterval(sendState, 1000);
                    render();
                } else {
                    send({ type: 'JOIN', id: myId, name: myName, avatar: myAvatar });
                    retryTimer = setInterval(() => {
                        if (!players.find(p => p.id === myId)) send({ type: 'JOIN', id: myId, name: myName, avatar: myAvatar });
                        else clearInterval(retryTimer);
                    }, 2000);
                }
            });

            client.on('message', (t, m) => {
                try {
                    const d = JSON.parse(m.toString());
                    if (d.sender !== myId) handle(d);
                } catch (e) {}
            });
        }

        function send(d) {
            d.sender = myId;
            client.publish(TOPIC_ROOT + roomCode, JSON.stringify(d));
        }

        function handle(d) {
            if (isHost) {
                if (d.type === 'JOIN') {
                    if (!players.find(p => p.id === d.id)) {
                        players.push({ id: d.id, name: d.name, avatar: d.avatar, hp: 3, maxHp: 3, dead: false, stunned: false });
                        addLog(`${d.name} entered.`, 'log-neut');
                        sendState();
                    }
                } 
                else if (d.type === 'TARGET') {
                    targetedId = d.targetId;
                    sendState();
                }
                else if (d.type === 'ATTACK') {
                    resolveCombat(d.sender, d.targetId, d.flavor);
                }
            } else {
                if (d.type === 'STATE') {
                    players = d.players;
                    if (turnIndex !== d.turnIndex) targetedId = null;
                    turnIndex = d.turnIndex;
                    phase = d.phase;
                    if (players[turnIndex] && players[turnIndex].id !== myId) targetedId = d.targetedId;
                    render();
                }
                else if (d.type === 'FX') {
                    showFloat(d.targetId, d.text, d.color);
                    showBigMsg(d.title, d.sub);
                    addLog(d.logMsg, d.logType);
                    // Show Thought Bubble
                    if(d.flavor && d.attId) showBubble(d.attId, d.flavor);
                }
            }
        }

        function sendState() {
            send({ type: 'STATE', players, turnIndex, phase, targetedId });
            render();
        }

        // --- D100 LOGIC ---
        function getOutcome(roll, attName, defName, flavor) {
            const r = { dmgDef: 0, dmgAtt: 0, healAtt: 0, stunDef: false, stunAtt: false, extraTurn: false, title: "", sub: "" };
            
            // Text Replacement Logic
            const rawText = getFlavorText(roll);
            const resText = rawText.replace(/\$1/g, defName).replace(/{user}/g, attName);
            
            // Combine with Flavor
            // "Attacker tries to X... BUT Result!"
            const flavorPrefix = flavor ? `${attName} ${flavor}... ` : "";
            
            if (roll <= 40) { r.title = "HIT"; r.dmgDef = 1; r.logType="log-hit"; } 
            else if (roll <= 70) { r.title = "BACKFIRE"; r.dmgAtt = 1; r.logType="log-bad"; }
            else if (roll <= 80) { r.title = "MISS"; }
            else if (roll <= 85) { r.title = "CRIT HIT"; r.dmgDef = 2; r.logType="log-crit"; }
            else if (roll <= 90) { r.title = "CRIT FAIL"; r.dmgAtt = 2; r.logType="log-bad"; }
            else if (roll <= 95) { r.title = "MUTUAL"; r.dmgDef = 2; r.dmgAtt = 2; r.logType="log-bad"; }
            else if (roll === 96) { r.title = "STUN"; r.dmgDef = 1; r.stunDef = true; r.logType="log-hit"; }
            else if (roll === 97) { r.title = "SELF STUN"; r.dmgAtt = 1; r.stunAtt = true; r.logType="log-bad"; }
            else if (roll === 98) { r.title = "DRAIN"; r.healAtt = 1; r.logType="log-hit"; }
            else if (roll === 99) { r.title = "STEAL"; r.dmgDef = 1; r.healAtt = 1; r.logType="log-crit"; }
            else if (roll === 100) { r.title = "ADRENALINE"; r.dmgDef = 1; r.extraTurn = true; r.logType="log-crit"; }
            
            r.sub = resText;
            r.logMsg = `${flavorPrefix} ${resText} [Roll: ${roll}]`;
            return r;
        }

        function resolveCombat(attId, defId, flavor) {
            const att = players.find(p => p.id === attId);
            const def = players.find(p => p.id === defId);
            if (!att || !def) return;

            phase = 'ROLLING';
            targetedId = defId;
            sendState();

            const roll = Math.floor(Math.random() * 100) + 1;
            const outcome = getOutcome(roll, att.name, def.name, flavor);

            // Phase 1: Show Thought Bubble immediately
            send({ type: 'FX', targetId: null, text: '', color: '', title: '', sub: '', logMsg: '', flavor: flavor, attId: attId });
            showBubble(attId, flavor);

            // Phase 2: Show Result
            setTimeout(() => {
                if (outcome.dmgDef) { def.hp -= outcome.dmgDef; if(def.hp < 0) def.hp = 0; }
                if (outcome.dmgAtt) { att.hp -= outcome.dmgAtt; if(att.hp < 0) att.hp = 0; }
                if (outcome.healAtt) { att.hp += outcome.healAtt; if(att.hp > 3) att.hp = 3; }
                
                if (def.hp === 0) def.dead = true;
                if (att.hp === 0) att.dead = true;

                if (outcome.stunDef) def.stunned = true;
                if (outcome.stunAtt) att.stunned = true;

                const color = outcome.dmgDef > 0 ? '#e94560' : '#fff';

                send({ 
                    type: 'FX', targetId: defId, text: outcome.title, color: color, 
                    title: `${roll}: ${outcome.title}`, sub: outcome.sub,
                    logMsg: outcome.logMsg, logType: outcome.logType 
                });
                
                showFloat(defId, outcome.title, color);
                showBigMsg(`${roll}: ${outcome.title}`, outcome.sub);
                addLog(outcome.logMsg, outcome.logType);

            }, 2000); // 2 second delay to read thought bubble

            setTimeout(() => {
                targetedId = null;
                const alive = players.filter(p => !p.dead);
                if (alive.length <= 1) {
                    phase = 'GAMEOVER';
                    if(alive.length === 1) launchConfetti();
                }
                else {
                    if (!outcome.extraTurn) {
                        let i = 0;
                        do {
                            turnIndex = (turnIndex + 1) % players.length;
                            const p = players[turnIndex];
                            if (!p.dead && p.stunned) { 
                                p.stunned = false; 
                                addLog(`${p.name} recovers from stun.`, 'log-neut');
                            } else { /* Valid */ }
                            i++;
                        } while ((players[turnIndex].dead || players[turnIndex].stunned) && i < 20);
                        
                        players.forEach((p, idx) => { if(idx !== turnIndex && !p.dead) p.stunned = false; });
                    }
                    phase = 'IDLE';
                }
                sendState();
            }, 5000); // Longer delay to read result
        }

        function clickPlayer(id) {
            if (phase !== 'IDLE') return;
            const turnP = players[turnIndex];
            if (!turnP || turnP.id !== myId) return;
            if (id === myId) return;
            
            const t = players.find(p => p.id === id);
            if (!t || t.dead) return;

            targetedId = id;
            if (isHost) sendState();
            else send({ type: 'TARGET', targetId: id });
            render();
        }

        function confirmAction() {
            if (isHost && phase === 'LOBBY') {
                if (players.length < 2) return alert("Need 2 players");
                phase = 'IDLE';
                addLog("GAME STARTED", "log-crit");
                sendState();
                return;
            }
            if (phase === 'GAMEOVER') { location.reload(); return; }
            if (phase === 'IDLE' && targetedId) {
                const txt = document.getElementById('attack-input').value;
                document.getElementById('attack-input').value = ""; // Clear

                if (isHost) resolveCombat(myId, targetedId, txt);
                else send({ type: 'ATTACK', targetId: targetedId, flavor: txt });
                
                phase = 'ROLLING'; 
                render();
            }
        }

        // --- VISUALS ---
        function launchConfetti() {
            var end = Date.now() + 3000;
            (function frame() {
                confetti({ particleCount: 5, angle: 60, spread: 55, origin: { x: 0 } });
                confetti({ particleCount: 5, angle: 120, spread: 55, origin: { x: 1 } });
                if (Date.now() < end) requestAnimationFrame(frame);
            }());
        }

        function showBigMsg(t, s) {
            const el = document.getElementById('roll-display');
            el.innerHTML = `<div>${t}</div><div class="roll-sub">${s}</div>`;
            el.classList.add('visible');
            setTimeout(() => el.classList.remove('visible'), 4000);
        }

        function showFloat(id, txt, col) {
            const el = document.getElementById(`av-${id}`);
            if(!el) return;
            const f = document.createElement('div');
            f.className = 'floater'; f.innerText=txt; f.style.color=col;
            el.appendChild(f);
            setTimeout(()=>f.remove(), 2000);
        }

        function showBubble(id, text) {
            if(!text) return;
            const el = document.getElementById(`bubble-${id}`);
            if(!el) return;
            el.innerText = text + "...";
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 2000);
        }

        function render() {
            const currentState = JSON.stringify({ players, turnIndex, phase, targetedId, myId });
            if (currentState === lastRenderState) return; 
            lastRenderState = currentState;

            const list = document.getElementById('player-list');
            const arena = document.getElementById('arena-layer');
            const bar = document.getElementById('top-bar');
            const btn = document.getElementById('btn-act');
            const inp = document.getElementById('attack-input');

            list.innerHTML = '';
            arena.innerHTML = '';

            const turnP = players[turnIndex] || {};
            const isMyTurn = turnP.id === myId;

            // UI LOGIC
            inp.style.display = 'none'; // Default hidden

            if (phase === 'LOBBY') {
                bar.innerText = `LOBBY: ${players.length} WARRIORS`;
                btn.innerHTML = "▶";
                btn.disabled = !isHost;
                btn.style.opacity = isHost ? 1 : 0.5;
            } else if (phase === 'GAMEOVER') {
                const w = players.find(p => !p.dead);
                bar.innerText = `WINNER: ${w?w.name:'NONE'}`;
                btn.innerHTML = "↺";
                btn.disabled = false;
                btn.style.opacity = 1;
                btn.onclick = () => location.reload();
                launchConfetti(); 
            } else if (phase === 'ROLLING') {
                bar.innerText = "ROLLING...";
                btn.disabled = true;
                btn.style.opacity = 0;
            } else {
                if (isMyTurn) {
                    if(targetedId) {
                        bar.innerText = "TYPE ACTION & FIRE";
                        btn.innerHTML = "✓";
                        btn.disabled = false;
                        btn.style.opacity = 1;
                        inp.style.display = 'block'; // Show input
                        inp.focus();
                    } else {
                        bar.innerText = "YOUR TURN - SELECT TARGET";
                        bar.style.color = "#2ecc71";
                        btn.disabled = true;
                        btn.style.opacity = 0.3;
                    }
                } else {
                    bar.innerText = `${turnP.name}'S TURN`;
                    bar.style.color = "#fff";
                    btn.disabled = true;
                    btn.style.opacity = 0;
                }
            }

            const radius = 220;
            players.forEach((p, i) => {
                const isTarget = (targetedId === p.id);
                const isTurn = (i === turnIndex);
                const canClick = (phase==='IDLE' && isMyTurn && !p.dead && p.id!==myId);

                let dots = '';
                const hpVal = Number(p.hp);
                for(let h=0; h<3; h++) dots += `<span class="hp-dot ${h<hpVal?'on':''}"></span>`;
                
                // SIDEBAR
                const card = document.createElement('div');
                card.className = `player-card ${p.dead?'dead':''} ${p.stunned?'stunned':''}`;
                if(canClick) card.classList.add('clickable');
                if(isTurn) card.classList.add('active');
                if(isTarget) card.classList.add('target');
                card.onclick = () => clickPlayer(p.id);
                card.innerHTML = `<img src="${p.avatar}" class="avatar"><div class="card-info"><div style="font-weight:bold">${p.name} <span class="status-badge">STUNNED</span></div><div class="hp-container">${dots}</div></div>`;
                list.appendChild(card);

                // ARENA
                if (!p.dead) {
                    const a = (i * (360/players.length)) - 90;
                    const rad = a * (Math.PI/180);
                    const x = Math.cos(rad)*radius; 
                    const y = Math.sin(rad)*radius;

                    const el = document.createElement('div');
                    el.className = `arena-p ${p.dead?'dead':''}`;
                    if(canClick) el.classList.add('clickable');
                    if(isTurn) el.classList.add('active');
                    if(isTarget) el.classList.add('target');
                    
                    el.style.left = `calc(50% + ${x}px)`;
                    el.style.top = `calc(50% + ${y}px)`;
                    el.id = `av-${p.id}`;
                    el.onclick = () => clickPlayer(p.id);
                    
                    el.innerHTML = `
                        <div class="bubble" id="bubble-${p.id}"></div>
                        <img src="${p.avatar}" class="arena-av">
                        <div class="arena-name">${p.name}</div>
                    `;
                    arena.appendChild(el);
                }
            });
        }

        window.addEventListener('resize', () => { lastRenderState=""; render(); });

    </script>
</body>
</html>
